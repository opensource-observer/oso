# Generated by ariadne-codegen
# Source: scheduler/client.graphql

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import DataModelKind


class LatestDataModel(BaseModel):
    id: str
    org_id: str = Field(alias="orgId")
    is_enabled: bool = Field(alias="isEnabled")
    created_at: Any = Field(alias="createdAt")
    latest_release: Optional["LatestDataModelLatestRelease"] = Field(
        alias="latestRelease"
    )


class LatestDataModelLatestRelease(BaseModel):
    id: str
    revision: "LatestDataModelLatestReleaseRevision"


class LatestDataModelLatestReleaseRevision(BaseModel):
    name: str
    description: Optional[str]
    code: str
    depends_on: Optional[List["LatestDataModelLatestReleaseRevisionDependsOn"]] = Field(
        alias="dependsOn"
    )
    hash: str
    kind: DataModelKind
    kind_options: Optional["LatestDataModelLatestReleaseRevisionKindOptions"] = Field(
        alias="kindOptions"
    )
    partitioned_by: Optional[List[str]] = Field(alias="partitionedBy")
    schema_: Optional[List["LatestDataModelLatestReleaseRevisionSchema"]] = Field(
        alias="schema"
    )
    start: Optional[Any]
    end: Optional[Any]
    clustered_by: Optional[List[str]] = Field(alias="clusteredBy")
    language: str


class LatestDataModelLatestReleaseRevisionDependsOn(BaseModel):
    alias: Optional[str]
    table_id: str = Field(alias="tableId")


class LatestDataModelLatestReleaseRevisionKindOptions(BaseModel):
    time_column: Optional[str] = Field(alias="timeColumn")
    time_column_format: Optional[str] = Field(alias="timeColumnFormat")
    batch_size: Optional[int] = Field(alias="batchSize")
    lookback: Optional[int]
    unique_key_columns: Optional[List[str]] = Field(alias="uniqueKeyColumns")
    when_matched_sql: Optional[str] = Field(alias="whenMatchedSql")
    merge_filter: Optional[str] = Field(alias="mergeFilter")
    valid_from_name: Optional[str] = Field(alias="validFromName")
    valid_to_name: Optional[str] = Field(alias="validToName")
    invalidate_hard_deletes: Optional[bool] = Field(alias="invalidateHardDeletes")
    updated_at_column: Optional[str] = Field(alias="updatedAtColumn")
    updated_at_as_valid_from: Optional[bool] = Field(alias="updatedAtAsValidFrom")
    scd_columns: Optional[List[str]] = Field(alias="scdColumns")
    execution_time_as_valid_from: Optional[bool] = Field(
        alias="executionTimeAsValidFrom"
    )


class LatestDataModelLatestReleaseRevisionSchema(BaseModel):
    name: str
    type: str
    description: Optional[str]


class DataModels(BaseModel):
    edges: List["DataModelsEdges"]


class DataModelsEdges(BaseModel):
    node: "DataModelsEdgesNode"


class DataModelsEdgesNode(LatestDataModel):
    pass


class DatasetCommon(BaseModel):
    id: str
    name: str
    display_name: Optional[str] = Field(alias="displayName")
    description: Optional[str]
    organization: "DatasetCommonOrganization"


class DatasetCommonOrganization(BaseModel):
    id: str
    name: str


LatestDataModel.model_rebuild()
DataModels.model_rebuild()
DatasetCommon.model_rebuild()
