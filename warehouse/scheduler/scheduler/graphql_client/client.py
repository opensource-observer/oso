# Generated by ariadne-codegen
# Source: scheduler/client.graphql

from typing import Any, Dict

from .async_base_client import AsyncBaseClient
from .enums import RunStatus, StepStatus
from .finish_run import FinishRun
from .finish_step import FinishStep
from .get_data_models import GetDataModels
from .start_step import StartStep


def gql(q: str) -> str:
    return q


class Client(AsyncBaseClient):
    async def finish_run(
        self, run_id: str, status: RunStatus, logs_url: str, **kwargs: Any
    ) -> FinishRun:
        query = gql(
            """
            mutation FinishRun($runId: ID!, $status: RunStatus!, $logsUrl: String!) {
              finishRun(input: {runId: $runId, status: $status, logsUrl: $logsUrl}) {
                success
                message
                run {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "runId": run_id,
            "status": status,
            "logsUrl": logs_url,
        }
        response = await self.execute(
            query=query, operation_name="FinishRun", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return FinishRun.model_validate(data)

    async def start_step(
        self, run_id: str, name: str, display_name: str, **kwargs: Any
    ) -> StartStep:
        query = gql(
            """
            mutation StartStep($runId: ID!, $name: String!, $displayName: String!) {
              startStep(input: {runId: $runId, name: $name, displayName: $displayName}) {
                success
                message
                step {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "runId": run_id,
            "name": name,
            "displayName": display_name,
        }
        response = await self.execute(
            query=query, operation_name="StartStep", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return StartStep.model_validate(data)

    async def finish_step(
        self, step_id: str, status: StepStatus, logs_url: str, **kwargs: Any
    ) -> FinishStep:
        query = gql(
            """
            mutation FinishStep($stepId: ID!, $status: StepStatus!, $logsUrl: String!) {
              finishStep(input: {stepId: $stepId, status: $status, logsUrl: $logsUrl}) {
                success
                message
                step {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "stepId": step_id,
            "status": status,
            "logsUrl": logs_url,
        }
        response = await self.execute(
            query=query, operation_name="FinishStep", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return FinishStep.model_validate(data)

    async def get_data_models(self, dataset_id: str, **kwargs: Any) -> GetDataModels:
        query = gql(
            """
            query GetDataModels($datasetId: ID!) {
              datasets(where: {id: {eq: $datasetId}}) {
                edges {
                  node {
                    ...DatasetCommon
                    typeDefinition {
                      __typename
                      ... on DataModelDefinition {
                        dataModels(where: {is_enabled: {eq: true}}) {
                          ...DataModels
                        }
                      }
                    }
                  }
                }
              }
            }

            fragment DataModels on DataModelConnection {
              edges {
                node {
                  ...LatestDataModel
                }
              }
            }

            fragment DatasetCommon on Dataset {
              id
              orgId
              displayName
              description
            }

            fragment LatestDataModel on DataModel {
              id
              orgId
              isEnabled
              createdAt
              latestRelease {
                id
                revision {
                  name
                  code
                  dependsOn {
                    alias
                    tableId
                  }
                  hash
                  kind
                  kindOptions {
                    timeColumn
                    timeColumnFormat
                    batchSize
                    lookback
                    uniqueKeyColumns
                    whenMatchedSql
                    mergeFilter
                    validFromName
                    validToName
                    invalidateHardDeletes
                    updatedAtColumn
                    updatedAtAsValidFrom
                    scdColumns
                    executionTimeAsValidFrom
                  }
                  partitionedBy
                  schema {
                    name
                    type
                    description
                  }
                  start
                  end
                  clusteredBy
                  language
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"datasetId": dataset_id}
        response = await self.execute(
            query=query, operation_name="GetDataModels", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetDataModels.model_validate(data)
