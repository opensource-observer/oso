# Generated by ariadne-codegen
# Source: ../../apps/frontend/app/api/v1/osograph/schema

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    DataConnectionType,
    DataIngestionFactoryType,
    DataModelKind,
    DatasetType,
    MemberRole,
    RunStatus,
    StepStatus,
)


class CreateDataConnectionInput(BaseModel):
    org_id: str = Field(alias="orgId")
    name: str
    type: DataConnectionType
    config: Any
    credentials: Any


class CreateDataIngestionInput(BaseModel):
    dataset_id: str = Field(alias="datasetId")
    factory_type: DataIngestionFactoryType = Field(alias="factoryType")
    config: Any


class CreateDataModelInput(BaseModel):
    org_id: str = Field(alias="orgId")
    dataset_id: str = Field(alias="datasetId")
    name: str
    is_enabled: Optional[bool] = Field(alias="isEnabled", default=None)


class UpdateDataModelInput(BaseModel):
    data_model_id: str = Field(alias="dataModelId")
    name: Optional[str] = None
    is_enabled: Optional[bool] = Field(alias="isEnabled", default=None)


class DataModelColumnInput(BaseModel):
    name: str
    type: str
    description: Optional[str] = None


class DataModelDependencyInput(BaseModel):
    data_model_id: str = Field(alias="dataModelId")
    alias: Optional[str] = None


class DataModelKindOptionsInput(BaseModel):
    time_column: Optional[str] = Field(alias="timeColumn", default=None)
    time_column_format: Optional[str] = Field(alias="timeColumnFormat", default=None)
    batch_size: Optional[int] = Field(alias="batchSize", default=None)
    lookback: Optional[int] = None
    unique_key_columns: Optional[List[str]] = Field(
        alias="uniqueKeyColumns", default=None
    )
    when_matched_sql: Optional[str] = Field(alias="whenMatchedSql", default=None)
    merge_filter: Optional[str] = Field(alias="mergeFilter", default=None)
    valid_from_name: Optional[str] = Field(alias="validFromName", default=None)
    valid_to_name: Optional[str] = Field(alias="validToName", default=None)
    invalidate_hard_deletes: Optional[bool] = Field(
        alias="invalidateHardDeletes", default=None
    )
    updated_at_column: Optional[str] = Field(alias="updatedAtColumn", default=None)
    updated_at_as_valid_from: Optional[bool] = Field(
        alias="updatedAtAsValidFrom", default=None
    )
    scd_columns: Optional[List[str]] = Field(alias="scdColumns", default=None)
    execution_time_as_valid_from: Optional[bool] = Field(
        alias="executionTimeAsValidFrom", default=None
    )


class CreateDataModelRevisionInput(BaseModel):
    data_model_id: str = Field(alias="dataModelId")
    name: str
    description: Optional[str] = None
    language: str
    code: str
    cron: str
    start: Optional[Any] = None
    end: Optional[Any] = None
    schema_: List["DataModelColumnInput"] = Field(alias="schema")
    depends_on: Optional[List["DataModelDependencyInput"]] = Field(
        alias="dependsOn", default=None
    )
    partitioned_by: Optional[List[str]] = Field(alias="partitionedBy", default=None)
    clustered_by: Optional[List[str]] = Field(alias="clusteredBy", default=None)
    kind: DataModelKind
    kind_options: Optional["DataModelKindOptionsInput"] = Field(
        alias="kindOptions", default=None
    )


class CreateDataModelReleaseInput(BaseModel):
    data_model_id: str = Field(alias="dataModelId")
    data_model_revision_id: str = Field(alias="dataModelRevisionId")
    description: Optional[str] = None


class CreateDatasetInput(BaseModel):
    org_id: str = Field(alias="orgId")
    "The organization ID the dataset belongs to"
    name: str
    "The name of the dataset. This must be unique within the organization."
    display_name: Optional[str] = Field(alias="displayName", default=None)
    "The display name of the dataset."
    description: Optional[str] = None
    "The description of the dataset."
    type: Optional[DatasetType] = DatasetType.USER_MODEL
    "The type of the dataset.\n\nTypes:\n  * USER_MODEL: Sometimes called a UDM, this dataset type contains\n    user-defined data models.\n  * DATA_INGESTION: This dataset type is used for datasets that are ingested\n    from external sources using strategies like REST/GraphQL APIs, file\n    uploads, etc.\n  * STATIC_MODEL: This is used for datasets composed of statically uploaded\n    models. Currently only CSV files are supported for static models."


class UpdateDatasetInput(BaseModel):
    id: str
    name: Optional[str] = None
    display_name: Optional[str] = Field(alias="displayName", default=None)
    description: Optional[str] = None


class CreateInvitationInput(BaseModel):
    org_id: str = Field(alias="orgId")
    email: str
    role: MemberRole = MemberRole.admin


class AcceptInvitationInput(BaseModel):
    invitation_id: str = Field(alias="invitationId")


class RevokeInvitationInput(BaseModel):
    invitation_id: str = Field(alias="invitationId")
    org_id: str = Field(alias="orgId")


class ModelColumnContextInput(BaseModel):
    name: str
    context: str


class UpdateModelContextInput(BaseModel):
    dataset_id: str = Field(alias="datasetId")
    model_id: str = Field(alias="modelId")
    context: Optional[str] = None
    column_context: Optional[List["ModelColumnContextInput"]] = Field(
        alias="columnContext", default=None
    )


class CreateNotebookInput(BaseModel):
    org_id: str = Field(alias="orgId")
    name: str
    description: Optional[str] = None


class UpdateNotebookInput(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None


class SaveNotebookPreviewInput(BaseModel):
    notebook_id: str = Field(alias="notebookId")
    preview: str


class AddUserByEmailInput(BaseModel):
    org_id: str = Field(alias="orgId")
    email: str
    role: MemberRole


class RemoveMemberInput(BaseModel):
    org_id: str = Field(alias="orgId")
    user_id: str = Field(alias="userId")


class UpdateMemberRoleInput(BaseModel):
    org_id: str = Field(alias="orgId")
    user_id: str = Field(alias="userId")
    role: MemberRole


class CreateUserModelRunRequestInput(BaseModel):
    dataset_id: str = Field(alias="datasetId")
    "The ID of the dataset to run. This must be a USER_MODEL dataset."
    selected_models: Optional[List[str]] = Field(alias="selectedModels", default=None)
    "For user model runs, users can optionally specify a list of data model release\nIDs to run. If not provided, all models will be run in topological order based\non dependencies."


class CreateDataIngestionRunRequestInput(BaseModel):
    dataset_id: str = Field(alias="datasetId")


class CreateDataConnectionRunRequestInput(BaseModel):
    dataset_id: str = Field(alias="datasetId")


class CreateStaticModelRunRequestInput(BaseModel):
    dataset_id: str = Field(alias="datasetId")
    "The ID of the static model dataset to run."
    selected_models: Optional[List[str]] = Field(alias="selectedModels", default=None)
    "For static model runs, users can optionally specify a list of model IDs to\nrun. If not provided, all models will be run."


class CancelRunInput(BaseModel):
    run_id: str = Field(alias="runId")


class CreateStaticModelInput(BaseModel):
    org_id: str = Field(alias="orgId")
    "The ID of the organization to which the static model belongs."
    dataset_id: str = Field(alias="datasetId")
    "The ID of the dataset associated with the static model."
    name: str
    "The desired name for the static model (must be unique within the organization)."


class UpdateStaticModelInput(BaseModel):
    static_model_id: str = Field(alias="staticModelId")
    name: Optional[str] = None


class StartRunInput(BaseModel):
    run_id: str = Field(alias="runId")


class UpdateMetadataInput(BaseModel):
    value: Any
    merge: Optional[bool] = False


class UpdateRunMetadataInput(BaseModel):
    run_id: str = Field(alias="runId")
    metadata: "UpdateMetadataInput"


class FinishRunInput(BaseModel):
    run_id: str = Field(alias="runId")
    status: RunStatus
    status_code: int = Field(alias="statusCode")
    logs_url: str = Field(alias="logsUrl")
    metadata: Optional["UpdateMetadataInput"] = None


class StartStepInput(BaseModel):
    run_id: str = Field(alias="runId")
    name: str
    display_name: str = Field(alias="displayName")


class FinishStepInput(BaseModel):
    step_id: str = Field(alias="stepId")
    status: StepStatus
    logs_url: str = Field(alias="logsUrl")


class CreateMaterializationInput(BaseModel):
    step_id: str = Field(alias="stepId")
    table_id: str = Field(alias="tableId")
    warehouse_fqn: str = Field(alias="warehouseFqn")
    schema_: List["DataModelColumnInput"] = Field(alias="schema")


class SavePublishedNotebookHtmlInput(BaseModel):
    notebook_id: str = Field(alias="notebookId")
    html_content: str = Field(alias="htmlContent")


class DataConnectionTableInput(BaseModel):
    name: str
    schema_: List["DataModelColumnInput"] = Field(alias="schema")


class DataConnectionSchemaInput(BaseModel):
    name: str
    tables: List["DataConnectionTableInput"]


class CreateDataConnectionDatasetsInput(BaseModel):
    run_id: str = Field(alias="runId")
    org_id: str = Field(alias="orgId")
    data_connection_id: str = Field(alias="dataConnectionId")
    schemas: List["DataConnectionSchemaInput"]


CreateDataModelRevisionInput.model_rebuild()
UpdateModelContextInput.model_rebuild()
UpdateRunMetadataInput.model_rebuild()
FinishRunInput.model_rebuild()
CreateMaterializationInput.model_rebuild()
DataConnectionTableInput.model_rebuild()
DataConnectionSchemaInput.model_rebuild()
CreateDataConnectionDatasetsInput.model_rebuild()
