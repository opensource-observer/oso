import base64
import hashlib
import os
import uuid
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from dataclasses import dataclass
from typing import Any, Generic, List, Optional, TypeVar, Union

import requests
from fastmcp import Context, FastMCP
from oso_mcp.server.graphql import generate_from_schema
from oso_mcp.server.graphql.mutations import RegexMutationFilter
from pyoso import Client, ClientConfig

from .config import MCPConfig

CURR_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_DIR = os.path.abspath(os.path.join(CURR_DIR, "../../../../"))

MCP_SSE_PORT = 8000

P = TypeVar("P")
R = TypeVar("R")


@dataclass
class McpErrorResponse(Generic[P]):
    tool_name: str
    error: str
    success: bool = False
    parameters: Optional[List[P]] = None


@dataclass
class McpSuccessResponse(Generic[P, R]):
    tool_name: str
    results: List[R]
    success: bool = True
    parameters: Optional[List[P]] = None


McpResponse = Union[McpErrorResponse[P], McpSuccessResponse[P, R]]


@dataclass
class AppContext:
    oso_client: Optional[Client] = None


def default_lifespan(config: MCPConfig):
    @asynccontextmanager
    async def app_lifespan(_server: FastMCP) -> AsyncIterator[AppContext]:
        """Manage application lifecycle with OSO client in context"""
        api_key = config.oso_api_key

        client = Client(
            api_key=api_key.get_secret_value(),
            client_opts=ClientConfig(base_url=config.pyoso_base_url),
        )
        context = AppContext(oso_client=client)

        try:
            yield context
        finally:
            pass

    return app_lifespan


def setup_mcp_app(config: MCPConfig):
    mcp = FastMCP(
        "OSO Data Lake Explorer",
        port=config.port,
        host=config.host,
        dependencies=["pyoso", "python-dotenv", "requests"],
        lifespan=default_lifespan(config),
    )

    # Wire autogenerated tools from graphql queries and mutations
    generate_from_schema(
        schema_path=os.path.join(
            REPO_DIR, "apps/frontend/app/api/v1/osograph/schema/graphql"
        ),
        mcp=mcp,
        config=config,
        filters=[
            RegexMutationFilter(patterns=["@mcp-ignore", "@system-only"]),
        ],
        client_schema_path="oso_mcp/server/graphql/queries",
    )

    @mcp.tool(
        description="Convert a natural language question into a SQL query using the OSO text2sql agent. Returns the generated SQL string.",
    )
    async def query_text2sql_agent(nl_query: str, ctx: Context) -> McpResponse:
        """
        Convert a natural language question into a SQL query using the OSO text2sql agent.

        Args:
            natural_language_query (str): The user's question in plain English.
            ctx (Context): The request context.

        Returns:
            McpSuccessResponse: Generated SQL string.
            McpErrorResponse: On error, contains error details.

        Example:
            query_text2sql_agent("Show all projects in the Ethereum collection", ctx)
        """
        if ctx:
            await ctx.info(f"Converting natural language query to SQL: {nl_query}")

        api_key = config.oso_api_key
        if not api_key:
            raise ValueError("OSO API key is not available in the context")

        url = config.text2sql_endpoint
        headers = {
            "Authorization": f"Bearer {api_key.get_secret_value()}",
            "Content-Type": "application/json",
        }

        data = {
            "id": str(uuid.uuid4()),
            "messages": [{"role": "user", "content": nl_query}],
        }

        response = requests.post(url, json=data, headers=headers)

        return McpSuccessResponse(
            tool_name="query_text2sql_agent",
            parameters=[nl_query],
            results=[response.json()["sql"]],
        )

    @mcp.tool(
        description="Generates a deterministic OSO ID (SHA256 hash base64 encoded) from a list of input values. Use this to verify IDs in tests.",
    )
    async def generate_oso_id(args: List[Any], ctx: Context) -> McpResponse:
        """
        Generates a deterministic OSO ID.

        Args:
            args: List of values to concatenate and hash (e.g. ["GITHUB", "my-org", "my-repo"] or ["GITHUB", "<repo_id>", 1])
        """
        # Logic matches warehouse/oso_sqlmesh/macros/oso_id.py
        normalized_args: List[str] = [str(a) for a in args]
        concatenated = "".join(normalized_args)
        sha_hash = hashlib.sha256(concatenated.encode("utf-8")).digest()
        # Trino/Presto TO_BASE64 usually returns standard base64
        # We need to ensure it matches exactly how the SQL dialect does it.
        # Based on the macro, it's a simple concat -> sha256 -> base64

        result_id = base64.b64encode(sha_hash).decode("utf-8")
        result_id_hex = sha_hash.hex()

        return McpSuccessResponse(
            tool_name="generate_oso_id",
            parameters=normalized_args,
            results=[
                f"ID (Hex): {result_id_hex}",
                f"ID (Base64): {result_id}",
            ],
        )

    return mcp
