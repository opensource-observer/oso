# Fragments for common types

fragment PageInfoFields on PageInfo {
  hasNextPage
  hasPreviousPage
  startCursor
  endCursor
}

fragment TableColumnFields on TableColumn {
  name
  type
  nullable
}

fragment OrganizationFields on Organization {
  id
  name
  displayName
  description
  createdAt
  updatedAt
}

fragment DatasetFields on Dataset {
  id
  orgId
  name
  displayName
  description
  type
  creatorId
  createdAt
  updatedAt
}

fragment DataModelFields on DataModel {
  id
  orgId
  name
  isEnabled
  createdAt
  updatedAt
}

fragment DataModelRevisionFields on DataModelRevision {
  id
  revisionNumber
  hash
  description
  language
  createdAt
}

fragment StaticModelFields on StaticModel {
  id
  orgId
  name
  createdAt
  updatedAt
}

fragment DataIngestionFields on DataIngestion {
  id
  orgId
  datasetId
  factoryType
  config
  createdAt
  updatedAt
}

fragment NotebookFields on Notebook {
  id
  orgId
  name
  description
  preview
  creatorId
  createdAt
  updatedAt
}

# Queries

query ListDatasets($first: Int = 50, $after: String, $where: JSON) {
  datasets(first: $first, after: $after, where: $where) {
    edges {
      node {
        ...DatasetFields
      }
      cursor
    }
    pageInfo {
      ...PageInfoFields
    }
    totalCount
  }
}

# Lists the tables for a given dataset. 
#
# Args:
#   datasetName (String!): The name of the dataset.
#   where (JSON!): Filter conditions for the tables.
query ListTablesForDataset($datasetName: String!) {
  datasets(where: { name: { eq: $datasetName } }, single: true) {
    edges {
      node {
        id
        name
        tables {
          edges {
            node {
              name
            }
          }
          pageInfo {
            ...PageInfoFields
          }
          totalCount
        }
      }
    }
  }
}

# List the runs for a given dataset, with optional filtering and pagination. The
# where parameter accepts a JSON object with field-level filtering. However, the
# fields should use snake_case due to how the filtering is implemented in the
# backend.
query ListTablesForDatasetWhere($datasetName: String!, $where: JSON!) {
  datasets(where: { name: { eq: $datasetName } }, single: true) {
    edges {
      node {
        id
        name
        tables(where: $where) {
          edges {
            node {
              id
              name
              columns {
                ...TableColumnFields
              }
            }
          }
          pageInfo {
            ...PageInfoFields
          }
          totalCount
        }
      }
    }
  }
}

# List all tables with optional filtering and pagination. The where parameter
# accepts a JSON object with field-level filtering. However, the fields should
# use snake_case due to how the filtering is implemented in the backend.
query ListDataModels($first: Int = 50, $after: String, $where: JSON) {
  dataModels(first: $first, after: $after, where: $where) {
    edges {
      node {
        ...DataModelFields
        dataset {
          ...DatasetFields
        }
        latestRevision {
          ...DataModelRevisionFields
        }
      }
      cursor
    }
    pageInfo {
      ...PageInfoFields
    }
    totalCount
  }
}

# List static models with optional filtering and pagination. The where parameter
# accepts a JSON object with field-level filtering. However, the fields should
# use snake_case due to how the filtering is implemented in the backend.
query ListStaticModels($first: Int = 50, $after: String, $where: JSON) {
  staticModels(first: $first, after: $after, where: $where) {
    edges {
      node {
        ...StaticModelFields
        dataset {
          ...DatasetFields
        }
      }
      cursor
    }
    pageInfo {
      ...PageInfoFields
    }
    totalCount
  }
}

# List data ingestions with optional filtering and pagination. The where
# parameter accepts a JSON object with field-level filtering. However, the
# fields should use snake_case due to how the filtering is implemented in the
# backend.
query ListDataIngestions($first: Int = 50, $after: String, $where: JSON) {
  datasets(first: $first, after: $after, where: $where) {
    edges {
      node {
        ...DatasetFields
        typeDefinition {
          ... on DataIngestionDefinition {
            dataIngestion {
              ...DataIngestionFields
            }
          }
        }
      }
      cursor
    }
    pageInfo {
      ...PageInfoFields
    }
    totalCount
  }
}

# List Notebooks with optional filtering and pagination. The where parameter
# accepts a JSON object with field-level filtering. However, the fields should
# use snake_case due to how the filtering is implemented in the backend.
query ListNotebooks($first: Int = 50, $after: String, $where: JSON) {
  notebooks(first: $first, after: $after, where: $where) {
    edges {
      node {
        ...NotebookFields
      }
      cursor
    }
    pageInfo {
      ...PageInfoFields
    }
    totalCount
  }
}

query GetNotebook($id: ID!) {
  notebooks(where: { id: { eq: $id } }, single: true) {
    edges {
      node {
        ...NotebookFields
      }
    }
  }
}

query GetNotebookByName($orgId: ID!, $name: String!) {
  notebooks(where: { org_id: { eq: $orgId }, name: { eq: $name } }, single: true) {
    edges {
      node {
        ...NotebookFields
      }
    }
  }
}

query GetDataModel($id: ID!) {
  dataModels(where: { id: { eq: $id } }, single: true) {
    edges {
      node {
        ...DataModelFields
        dataset {
          ...DatasetFields
        }
        latestRevision {
          ...DataModelRevisionFields
        }
      }
    }
  }
}

query GetDataModelByName($orgId: ID!, $datasetId: ID!, $name: String!) {
  dataModels(where: { org_id: { eq: $orgId }, datasetId: { eq: $datasetId }, name: { eq: $name } }, single: true) {
    edges {
      node {
        ...DataModelFields
        dataset {
          ...DatasetFields
        }
        latestRevision {
          ...DataModelRevisionFields
        }
      }
    }
  }
}

query GetStaticModel($id: ID!) {
  staticModels(where: { id: { eq: $id } }, single: true) {
    edges {
      node {
        ...StaticModelFields
        dataset {
          ...DatasetFields
        }
      }
    }
  }
}

query GetStaticModelByName($orgId: ID!, $datasetId: ID!, $name: String!) {
  staticModels(where: { org_id: { eq: $orgId }, datasetId: { eq: $datasetId }, name: { eq: $name } }, single: true) {
    edges {
      node {
        ...StaticModelFields
        dataset {
          ...DatasetFields
        }
      }
    }
  }
}

query GetDataset($id: ID!) {
  datasets(where: { id: { eq: $id } }, single: true) {
    edges {
      node {
        ...DatasetFields
      }
    }
  }
}

query GetDatasetByName($orgId: ID!, $name: String!) {
  datasets(where: { org_id: { eq: $orgId }, name: { eq: $name } }, single: true) {
    edges {
      node {
        ...DatasetFields
      }
    }
  }
}

query GetDataIngestion($datasetId: ID!) {
  datasets(where: { id: { eq: $datasetId } }, single: true) {
    edges {
      node {
        ...DatasetFields
        typeDefinition {
          ... on DataIngestionDefinition {
            dataIngestion {
              ...DataIngestionFields
            }
          }
        }
      }
    }
  }
}

query GetDataIngestionByName($orgId: ID!, $datasetName: String!) {
  datasets(where: { org_id: { eq: $orgId }, name: { eq: $datasetName } }, single: true) {
    edges {
      node {
        ...DatasetFields
        typeDefinition {
          ... on DataIngestionDefinition {
            dataIngestion {
              ...DataIngestionFields
            }
          }
        }
      }
    }
  }
}

query GetViewer($first: Int = 50, $after: String) {
  viewer {
    id
    email
    fullName
    avatarUrl
    organizations(first: $first, after: $after) {
      edges {
        node {
          ...OrganizationFields
        }
        cursor
      }
      pageInfo {
        ...PageInfoFields
      }
      totalCount
    }
  }
}

# Retrieve a single run by ID, along with its associated dataset if it exists.
# The logsUrl field is included to allow clients to fetch the logs for the run.
query GetRun($id: ID!) {
  runs(where: { id: { eq: $id } }, single: true) {
    edges {
      node {
        id
        datasetId
        dataset {
          ...DatasetFields
        }
        runType
        triggerType
        requestedBy {
          id
          email
          fullName
        }
        status
        startedAt
        finishedAt
        logsUrl
        metadata
      }
    }
  }
}

query GetRunsForDataset($datasetId: ID!, $first: Int = 50, $after: String) {
  runs(where: { dataset_id: { eq: $datasetId } }, first: $first, after: $after) {
    edges {
      node {
        id
        datasetId
        runType
        triggerType
        requestedBy {
          id
          email
          fullName
        }
        status
        startedAt
        finishedAt
        logsUrl
        metadata
      }
      cursor
    }
    pageInfo {
      ...PageInfoFields
    }
    totalCount
  }
}