# Resolver Builders - Type-Safe GraphQL Resolver Development

The resolver builder is a fluent API for creating GraphQL resolvers with
compile-time type safety, composable middleware, and reduced boilerplate code.
We use the `typescript-resolvers` generated types as the basis for our resolver
defintions and the builder interface ensures that our resolvers always conform
to the expected types while allowing us to easily add common functionality like
authentication, authorization, validation, and logging through reusable
middleware.

## Table of Contents

- [Quick Start](#quick-start)
- [Integration with Generated Types](#integration-with-generated-types)
- [Core Concepts](#core-concepts)
- [API Reference](#api-reference)
- [Built-in Middleware](#built-in-enhancers)
- [Examples](#examples)
- [Creating Custom Middleware](#creating-custom-enhancers)
- [Type Safety](#type-safety)
- [Best Practices](#best-practices)

## Quick Start

```typescript
import { createResolver } from "./resolver-builder";
import { withValidation, requireOrgAccess } from "./resolver-enhancers";
import { CreateDatasetSchema } from "./validation";
import type { CreateDatasetPayload } from "@/lib/graphql/generated/graphql";

export const createDataset = createResolver<CreateDatasetPayload>()
  .use(withValidation(CreateDatasetSchema))
  .use(requireOrgAccess((args) => args.input.orgId))
  .resolve(async (parent, args, context) => {
    // args.input is fully typed from schema
    // context.client, context.orgRole, context.userId are guaranteed to exist

    const { data: dataset, error } = await context.client
      .from("datasets")
      .insert({
        name: args.input.name,
        org_id: args.input.orgId,
      })
      .select()
      .single();

    if (error) throw ServerErrors.database(error.message);
    return { dataset, success: true, message: "Dataset created" };
  });
```

## Integration with Generated Types

The resolver builder works seamlessly with the autogenerated GraphQL types. Here's how to use it in a resolver module:

### With `GraphQLResolverModule` Pattern

```typescript
import type { GraphQLResolverModule } from "@/app/api/v1/osograph/types/utils";
import type { GraphQLContext } from "@/app/api/v1/osograph/types/context";
import type {
  CreateDatasetPayload,
  UpdateDatasetPayload,
  MutationCreateDatasetArgs,
} from "@/lib/graphql/generated/graphql";
import { createResolver } from "./resolver-builder";
import { withValidation, requireOrgAccess } from "./resolver-enhancers";

// Define your resolver module with typed resolvers
export const datasetMutations: GraphQLResolverModule<GraphQLContext>["Mutation"] =
  {
    createDataset: createResolver<CreateDatasetPayload>()
      .use(withValidation(CreateDatasetSchema))
      .use(requireOrgAccess((args) => args.input.orgId))
      .resolve(async (parent, args, context) => {
        const { data: dataset } = await context.client
          .from("datasets")
          .insert({ name: args.input.name, org_id: args.input.orgId })
          .select()
          .single();

        return { dataset, success: true, message: "Created" };
      }),

    updateDataset: createResolver<UpdateDatasetPayload>()
      .use(withValidation(UpdateDatasetSchema))
      .use(
        requireResourceAccess({
          resourceType: "dataset",
          getResourceId: (args) => args.input.datasetId,
          requiredPermission: "write",
        }),
      )
      .resolve(async (parent, args, context) => {
        const { data: dataset } = await context.client
          .from("datasets")
          .update({ name: args.input.name })
          .eq("id", args.input.datasetId)
          .select()
          .single();

        return { dataset, success: true, message: "Updated" };
      }),
  };
```

### With Individual Exports

```typescript
import type { Viewer } from "@/lib/graphql/generated/graphql";
import { createResolver } from "./resolver-builder";
import { requireAuth } from "./resolver-enhancers";

// Export individual resolvers
export const viewerQuery = createResolver<Viewer>()
  .use(requireAuth())
  .resolve(async (parent, args, context) => {
    return {
      userId: context.userId,
    };
  });

export const createDataset = createResolver<CreateDatasetPayload>()
  .use(withValidation(CreateDatasetSchema))
  .use(requireOrgAccess((args) => args.input.orgId))
  .resolve(async (parent, args, context) => {
    // Implementation
  });
```

### Type Resolvers (Field Resolvers)

```typescript
import type {
  Dataset,
  Organization,
  TableConnection,
} from "@/lib/graphql/generated/graphql";
import type { DatasetsRow } from "@/lib/types/schema-types";
import { createResolver } from "./resolver-builder";

export const DatasetTypeResolvers: GraphQLResolverModule<GraphQLContext>["Dataset"] =
  {
    // Simple field resolver
    organization: createResolver<Organization, DatasetsRow>().resolve(
      async (parent, args, context) => {
        // parent is typed as DatasetsRow (from the mapper)
        const { data: org } = await context.client
          .from("organizations")
          .select("*")
          .eq("id", parent.org_id)
          .single();

        return org;
      },
    ),

    // Field resolver with args
    tables: createResolver<TableConnection, DatasetsRow>().resolve(
      async (parent, args, context) => {
        const tables = await fetchTablesForDataset(parent.id, context.client);
        return buildConnection(tables, args);
      },
    ),
  };
```

## Core Concepts

### Middleware

**Middleware** are functions that transform `context` and/or `args`. They are applied sequentially in the order they're added via `.use()`.

Each enhancer:

- Receives `(context, args)` from the previous enhancer
- Returns `Promise<{ context, args }>` with potentially enhanced types
- Can add properties to context (like `client`, `userId`)
- Can validate and narrow the args type

### Builder Pattern

The resolver builder uses a **fluent builder pattern**:

```typescript
createResolver<TResult>() // Start building
  .use(enhancer1) // Add first enhancer
  .use(enhancer2) // Add second enhancer
  .use(enhancer3) // Add third enhancer
  .resolve(handler); // Finish with handler
```

Each `.use()` call returns a NEW builder instance with updated type parameters, ensuring full type safety.

### Type Progressive Enhancement

As you chain `.use()` calls, the types are progressively enhanced:

```typescript
createResolver<CreateDatasetPayload>()
  // TContext = GraphQLContext
  // TArgs = any

  .use(withValidation(CreateDatasetSchema))
  // TArgs = { input: z.infer<typeof CreateDatasetSchema> }

  .use(requireOrgAccess((args) => args.input.orgId))
  // TContext = OrgAccessContext<TArgs>
  // TypeScript now knows context.client, context.orgRole exist

  .resolve(async (parent, args, context) => {
    // Full IntelliSense for args.input and context properties!
  });
```

## API Reference

### `createResolver<TResult, TParent?, TArgs?>()`

Creates a new resolver builder.

**Type Parameters:**

- `TResult` - The return type of the resolver (required) - should match a generated GraphQL type
- `TParent` - The parent object type (defaults to `any`, use a mapped type for field resolvers)
- `TArgs` - The args type (defaults to `any`)

**Returns:** `ResolverBuilder<TResult, TParent, GraphQLContext, TArgs>`

### `.use(enhancer)`

Adds an enhancer to the resolver chain.

**Parameters:**

- `enhancer` - An enhancer function that transforms context/args

**Returns:** A new `ResolverBuilder` with updated type parameters

### `.resolve(handler)`

Builds the final resolver function.

**Parameters:**

- `handler` - The resolver implementation function

**Returns:** A GraphQL `ResolverFn` compatible with generated types

## Built-in Middleware

### `requireAuth()`

Validates that the user is authenticated.

**Adds to context:**

- `client`: SupabaseClient
- `userId`: string

```typescript
.use(requireAuth())
```

### `requireOrgAccess(getOrgId)`

Validates that the user is a member of the specified organization.

**Parameters:**

- `getOrgId` - Function to extract orgId from args

**Adds to context:**

- `client`: SupabaseClient
- `userId`: string
- `orgRole`: OrgRole ('owner' | 'admin' | 'member')
- `orgId`: string

```typescript
.use(requireOrgAccess((args) => args.input.orgId))
```

### `requireResourceAccess(config)`

Validates that the user has the required permission on a resource.

**Parameters:**

- `config.resourceType` - The type of resource ('notebook', 'dataset', etc.)
- `config.getResourceId` - Function to extract resource ID from args
- `config.requiredPermission` - Required permission level ('read', 'write', etc.)

**Adds to context:**

- `client`: SupabaseClient
- `userId`: string
- `permissionLevel`: PermissionLevel
- `resourceId`: string

```typescript
.use(requireResourceAccess({
  resourceType: 'notebook',
  getResourceId: (args) => args.input.notebookId,
  requiredPermission: 'write',
}))
```

### `withValidation(schema)`

Validates input against a Zod schema.

**Parameters:**

- `schema` - Zod schema to validate against

**Transforms args:**

- `args.input` becomes typed as `z.infer<typeof schema>`

```typescript
.use(withValidation(CreateDatasetSchema))
```

### `withLogging(label)`

Logs resolver execution for debugging.

**Parameters:**

- `label` - Label for the resolver (typically the resolver name)

```typescript
.use(withLogging('createDataset'))
```

## Examples

### Example 1: Mutation Resolver Module

```typescript
// File: /schema/resolvers/resource/dataset/mutations.ts
import type { GraphQLResolverModule } from "@/app/api/v1/osograph/types/utils";
import type { GraphQLContext } from "@/app/api/v1/osograph/types/context";
import type {
  CreateDatasetPayload,
  UpdateDatasetPayload,
  DeleteDatasetPayload,
} from "@/lib/graphql/generated/graphql";
import { createResolver } from "@/app/api/v1/osograph/utils/resolver-builder";
import {
  withValidation,
  requireOrgAccess,
  requireResourceAccess,
} from "@/app/api/v1/osograph/utils/resolver-enhancers";
import {
  CreateDatasetSchema,
  UpdateDatasetSchema,
  DeleteDatasetSchema,
} from "@/app/api/v1/osograph/utils/validation";
import { ServerErrors } from "@/app/api/v1/osograph/utils/errors";

export const datasetMutations: GraphQLResolverModule<GraphQLContext>["Mutation"] =
  {
    createDataset: createResolver<CreateDatasetPayload>()
      .use(withValidation(CreateDatasetSchema))
      .use(requireOrgAccess((args) => args.input.orgId))
      .resolve(async (parent, args, context) => {
        const { data: dataset, error } = await context.client
          .from("datasets")
          .insert({
            name: args.input.name,
            org_id: args.input.orgId,
            description: args.input.description,
          })
          .select()
          .single();

        if (error) throw ServerErrors.database(error.message);
        return {
          dataset,
          success: true,
          message: "Dataset created successfully",
        };
      }),

    updateDataset: createResolver<UpdateDatasetPayload>()
      .use(withValidation(UpdateDatasetSchema))
      .use(
        requireResourceAccess({
          resourceType: "dataset",
          getResourceId: (args) => args.input.datasetId,
          requiredPermission: "write",
        }),
      )
      .resolve(async (parent, args, context) => {
        const { data: dataset, error } = await context.client
          .from("datasets")
          .update({
            name: args.input.name,
            description: args.input.description,
          })
          .eq("id", args.input.datasetId)
          .select()
          .single();

        if (error) throw ServerErrors.database(error.message);
        return {
          dataset,
          success: true,
          message: "Dataset updated successfully",
        };
      }),

    deleteDataset: createResolver<DeleteDatasetPayload>()
      .use(withValidation(DeleteDatasetSchema))
      .use(
        requireResourceAccess({
          resourceType: "dataset",
          getResourceId: (args) => args.input.datasetId,
          requiredPermission: "admin",
        }),
      )
      .resolve(async (parent, args, context) => {
        const { error } = await context.client
          .from("datasets")
          .delete()
          .eq("id", args.input.datasetId);

        if (error) throw ServerErrors.database(error.message);
        return { success: true, message: "Dataset deleted successfully" };
      }),
  };
```

### Example 2: Query Resolver Module

```typescript
// File: /schema/resolvers/user/viewer/queries.ts
import type { GraphQLResolverModule } from "@/app/api/v1/osograph/types/utils";
import type { GraphQLContext } from "@/app/api/v1/osograph/types/context";
import type { Viewer } from "@/lib/graphql/generated/graphql";
import { createResolver } from "@/app/api/v1/osograph/utils/resolver-builder";
import { requireAuth } from "@/app/api/v1/osograph/utils/resolver-enhancers";

export const viewerQueries: GraphQLResolverModule<GraphQLContext>["Query"] = {
  viewer: createResolver<Viewer>()
    .use(requireAuth())
    .resolve(async (parent, args, context) => {
      // Return an object that will be resolved by Viewer type resolvers
      return {
        userId: context.userId,
      };
    }),
};
```

### Example 3: Field Resolvers (Type Resolvers)

```typescript
// File: /schema/resolvers/resource/dataset/type-resolvers.ts
import type { GraphQLResolverModule } from "@/app/api/v1/osograph/types/utils";
import type { GraphQLContext } from "@/app/api/v1/osograph/types/context";
import type {
  Organization,
  TableConnection,
  DatasetTypeDefinition,
} from "@/lib/graphql/generated/graphql";
import type { DatasetsRow } from "@/lib/types/schema-types";
import { createResolver } from "@/app/api/v1/osograph/utils/resolver-builder";

export const DatasetTypeResolvers: GraphQLResolverModule<GraphQLContext>["Dataset"] =
  {
    // Resolve the organization field
    organization: createResolver<Organization, DatasetsRow>().resolve(
      async (parent, args, context) => {
        const { data: org } = await context.client
          .from("organizations")
          .select("*")
          .eq("id", parent.org_id)
          .single();

        return org;
      },
    ),

    // Resolve tables connection with pagination
    tables: createResolver<TableConnection, DatasetsRow>().resolve(
      async (parent, args, context) => {
        const tables = await fetchTablesForDataset(
          parent.id,
          args,
          context.client,
        );
        return buildConnection(tables, args);
      },
    ),

    // Resolve polymorphic type definition field
    typeDefinition: createResolver<
      DatasetTypeDefinition,
      DatasetsRow
    >().resolve(async (parent, args, context) => {
      switch (parent.dataset_type) {
        case "USER_MODEL":
          return {
            __typename: "DataModelDefinition",
            orgId: parent.org_id,
            datasetId: parent.id,
          };
        case "DATA_INGESTION":
          return {
            __typename: "DataIngestionDefinition",
            orgId: parent.org_id,
            datasetId: parent.id,
          };
        // ... other cases
      }
    }),
  };
```

### Example 4: Reusable Middleware Combinations

```typescript
// Create a base resolver with common middleware
const notebookMutationBase = <T>() =>
  createResolver<T>().use(withLogging("notebook-mutation"));

// Use the base for multiple mutations
export const notebookMutations: GraphQLResolverModule<GraphQLContext>["Mutation"] =
  {
    createNotebook: notebookMutationBase<CreateNotebookPayload>()
      .use(withValidation(CreateNotebookSchema))
      .use(requireOrgAccess((args) => args.input.orgId))
      .resolve(async (parent, args, context) => {
        // Implementation
      }),

    updateNotebook: notebookMutationBase<UpdateNotebookPayload>()
      .use(withValidation(UpdateNotebookSchema))
      .use(
        requireResourceAccess({
          resourceType: "notebook",
          getResourceId: (args) => args.input.notebookId,
          requiredPermission: "write",
        }),
      )
      .resolve(async (parent, args, context) => {
        // Implementation
      }),
  };
```

## Creating Custom Middleware

You can create custom enhancers for your specific needs:

```typescript
import type { Middleware } from "./resolver-builder";
import type { GraphQLContext } from "./types/context";

// Define a custom branded context type
declare const AuditLoggedBrand: unique symbol;
type AuditLoggedContext = GraphQLContext & {
  [AuditLoggedBrand]: true;
  auditLogId: string;
};

// Create the middleware factory
export function withAuditLog<TArgs>(
  getAction: (args: TArgs) => string,
): Middleware<GraphQLContext, AuditLoggedContext, TArgs, TArgs> {
  return async (context, args) => {
    const auditLog = await logAction({
      userId: context.user.id,
      action: getAction(args),
      timestamp: new Date(),
    });

    return {
      context: {
        ...context,
        auditLogId: auditLog.id,
      } as AuditLoggedContext,
      args,
    };
  };
}

// Use it in resolvers
export const createDataModel = createResolver<CreateDataModelPayload>()
  .use(withValidation(CreateDataModelSchema))
  .use(requireOrgAccess((args) => args.input.orgId))
  .use(withAuditLog((args) => "create_data_model"))
  .resolve(async (parent, args, context) => {
    console.log(`Audit log ID: ${context.auditLogId}`);
    // Implementation
  });
```

## Type Safety

### Compile-Time Guarantees

The resolver builder provides compile-time type safety through:

1. **Branded Types**: Enhanced context types use branded types to ensure you can only access properties that have been added by enhancers.

2. **Progressive Type Enhancement**: Each `.use()` call updates the builder's type parameters, so TypeScript tracks exactly what properties are available.

3. **Type Inference**: Validation enhancers automatically infer the args type from your Zod schema.

### Example of Type Safety

```typescript
// ❌ TypeScript error: Property 'client' does not exist
createResolver<CreateDatasetPayload>().resolve(
  async (parent, args, context) => {
    context.client; // Error!
  },
);

// ✅ OK: client is available after requireAuth()
createResolver<CreateDatasetPayload>()
  .use(requireAuth())
  .resolve(async (parent, args, context) => {
    context.client; // Works!
  });
```

## Best Practices

### 1. Apply Validation Early

Always use `withValidation()` as the first enhancer to ensure args are validated before any other logic runs:

```typescript
createResolver<MyPayload>()
  .use(withValidation(MySchema))  // ✅ First
  .use(requireOrgAccess(...))
  .resolve(...)
```

### 2. Use Generated Types

Always specify the return type using generated GraphQL types:

```typescript
import type { CreateDatasetPayload } from "@/lib/graphql/generated/graphql";

// ✅ Good: Uses generated type
createResolver<CreateDatasetPayload>();

// ❌ Bad: No type specified
createResolver();
```

### 3. Organize Resolvers by Feature

Group related resolvers in modules:

```
/schema/resolvers/
├── resource/
│   ├── dataset/
│   │   ├── mutations.ts
│   │   ├── queries.ts
│   │   └── type-resolvers.ts
│   └── notebook/
│       ├── mutations.ts
│       └── type-resolvers.ts
└── user/
    └── viewer/
        ├── queries.ts
        └── type-resolvers.ts
```

### 4. Keep Resolvers Focused

The resolver handler should focus on business logic only. Let enhancers handle cross-cutting concerns like auth, validation, and logging.

## Migration from Manual Resolvers

### Before (Manual)

```typescript
export const organizationMemberMutations: GraphQLResolverModule<GraphQLContext>["Mutation"] =
  {
    addUserByEmail: async (
      _: unknown,
      args: MutationAddUserByEmailArgs,
      context: GraphQLContext,
    ) => {
      // Manual validation
      const input = validateInput(AddUserByEmailSchema, args.input);

      // Manual access control
      const { client } = await getOrgScopedClient(context, input.orgId);

      // Business logic
      const { data: member, error } = await client
        .from("users_by_organization")
        .insert({ org_id: input.orgId, user_id: userProfile.id })
        .select()
        .single();

      if (error) throw ServerErrors.database(error.message);
      return { member, message: "User added", success: true };
    },
  };
```

### After (Builder)

```typescript
export const organizationMemberMutations: GraphQLResolverModule<GraphQLContext>["Mutation"] =
  {
    addUserByEmail: createResolver<AddUserByEmailPayload>()
      .use(withValidation(AddUserByEmailSchema))
      .use(requireOrgAccess((args) => args.input.orgId))
      .resolve(async (parent, args, context) => {
        // Just business logic!
        const { data: member, error } = await context.client
          .from("users_by_organization")
          .insert({ org_id: args.input.orgId, user_id: userProfile.id })
          .select()
          .single();

        if (error) throw ServerErrors.database(error.message);
        return { member, message: "User added", success: true };
      }),
  };
```

**Benefits:**

- ~30-50% less boilerplate code
- Compile-time type safety (can't forget validation or auth)
- Better code organization (separation of concerns)
- Reusable enhancers
- Full IntelliSense support
- Perfect integration with generated types
