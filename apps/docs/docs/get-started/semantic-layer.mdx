---
title: "Using the Semantic Layer"
sidebar_position: 2
---

import AnatomyOfSemanticLayer from "../_common/semantic-layer/_anatomy-of-semantic-layer.mdx";

After some exploration with the OSO data, you may find that the available tables
have a complex set of relationships that can make it difficult to understand how
to properly write some set of queries. Understanding the relationships of the
tables key to being able to make meaningful queries against the OSO data. As
part of the the `pyoso`, we now include an experimental semantic layer.

The semantic layer provides a curated data model that can be used to query the
OSO data warehouse through a python interface. The explicit relationships and
attributes inherent in this semantic layer allow for automatically resolving
join paths, aggregations, and other aspects of using the data model so that
making informed queries doesn't require expertise in the universe of OSO tables.

## Querying against the semantic layer

### A basic query

Let's consider a basic query that only seeks to find all artifacts within a
collection. If you only cared about the artifact name and collection name
attributes this semantic query would look like this:

```python
from pyoso import Client

oso = Client()

query = oso.semantic.select(
    "collection.name"
    "artifact.name",
)
```

This query simply `select`s the `name` attribute from both the `collection`
model and the `artifact` model.

To render this semantic query to sql you can do:

```python
print(query.sql())
```

By default this will use the trino SQL dialect and the printed query will look
something like this:

```sql
SELECT
  collection_db6d9b45.collection_name AS collection_name,
  artifact_8e5b948a.artifact_name AS artifact_name
FROM oso.artifacts_v1 AS artifact_8e5b948a
LEFT JOIN oso.artifacts_by_project_v1 AS artifacts_by_project_v1_4f760b72
  ON artifact_8e5b948a.artifact_id = artifacts_by_project_v1_4f760b72.artifact_id
LEFT JOIN oso.projects_v1 AS project_46f86faa
  ON artifacts_by_project_v1_4f760b72.project_id = project_46f86faa.project_id
LEFT JOIN oso.projects_by_collection_v1 AS projects_by_collection_v1_483e7c1c
  ON project_46f86faa.project_id = projects_by_collection_v1_483e7c1c.project_id
LEFT JOIN oso.collections_v1 AS collection_db6d9b45
  ON projects_by_collection_v1_483e7c1c.collection_id = collection_db6d9b45.collection_id
GROUP BY
  1,
  2
```

As evident in the generated sql, the semantic query tool automatically decides the proper join path and automatically groups the collection name and artifact name.

:::Note 
For this specific example, a custom written query could produce one less
join, but due to the way the registry has is modeled this result is currently
as intended.
:::

To execute this generated sql query and return the associated dataframe one can simply do:

```python
df = query.as_pandas()
```

### Querying with a relationship

Relaltionships are a key part of the semantic layer. They allow us to define how models relate to each other. Unlike, SQL you don't explicity define join paths. The semantic layer resolves these paths for you. For dealing with relationships we have special semantics when a relationship attribute is included in the query. 

#### Selecting just a relationship attribute

The `project` model has a relationship to the collection via it's `collection` relationship attribute. 

```python
query = oso.semantic.select(
  "project.projects_by_collection",
)
```

This would produce the following SQL:

```sql
SELECT
  projects_by_collection_v1_8247793e.collection_id AS project_collection
FROM oso.projects_v1 AS project_46f86faa
LEFT JOIN oso.projects_by_collection_v1 AS projects_by_collection_v1_8247793e
  ON project_46f86faa.project_id = projects_by_collection_v1_8247793e.project_id
GROUP BY
  1
```

When a relationship attribute is selected only the key used to reference the foreign model is returned. In the case of `project.collection`, the collection is referenced by it's collection id in a foreign key relationship. 

We can also include the relationship attribute to provide a filtering
context without having an explicit filter. For instance if we wanted to only 
get the project names that exist in _any_ collection, we could do this:

```python
query = oso.semantic.select(
    "project.name",
    "collection",
)
```

As not all artifacts are part of a project, this will only return the projects that have a relationship to a collection. This would produce the following SQL:

```sql
SELECT
  project_46f86faa.project_name AS project_name,
  project_46f86faa.collection_id AS project_collection
FROM oso.projects_v1 AS project_46f86faa
WHERE
  project_46f86faa.collection_id IS NOT NULL
GROUP BY
  1,
  2
```

#### Handling ambiguous joins

The previous examples only involved a fairly simple join relationships.
Artifacts are related to Collections via their relationship to Projects and some
intermediate tables in between. However, in the OSO data model we also have a
concept of Events. There are multiple event tables but let's consider the events
from github. In the current semantic layer the model responsible for the github
events is `github_event`. All of the event models have a generic interface that
involves the following relationships:

- `from` - The artifact that initiated an event
- `to` - The artifact that received an event

If we instead wanted to make the following semantic query:

```python
query = oso.semantic.select(
    "github_event.time",
    "collection.name"
    "artifact.name",
)
```

If you try to render this sql:

```python
query.sql()
```

This would result in a `ModelHasAmbiguousJoinPath` exception. This "ambiguous"
join is because there are two possible paths to join `github_event` to both the
`artifact` model the `collection` model. In such a case, we need to give the
semantic querying mechanism an explicit path for which to join against the
`github_event` table. To do this, we use a special arrow operator `->` that will
define the path we want to relate through for the ambiguous join. For instance,
if what we cared about are the event times and the associated artifacts and
collections that received an event we'd do this:

```python
query = oso.semantic.select(
    "github_event.time",
    "github_event.to->collection.name"
    "github_event.to->artifact.name",
)
```

This would then produce the following SQL:

```sql
SELECT
  collection_2083abff.collection_name AS github_event_to__collection_name,
  artifact_95a01095.artifact_name AS github_event_from__artifact_name,
  github_event_420c9a8e.time AS github_event_time
FROM oso.int_events__github AS github_event_420c9a8e
LEFT JOIN oso.artifacts_v1 AS artifact_1b71f23f
  ON github_event_420c9a8e.to_artifact_id = artifact_1b71f23f.artifact_id
LEFT JOIN oso.artifacts_by_project_v1 AS artifacts_by_project_v1_5ee26df1
  ON artifact_1b71f23f.artifact_id = artifacts_by_project_v1_5ee26df1.artifact_id
LEFT JOIN oso.projects_v1 AS project_e17705b6
  ON artifacts_by_project_v1_5ee26df1.project_id = project_e17705b6.project_id
LEFT JOIN oso.projects_by_collection_v1 AS projects_by_collection_v1_8247793e
  ON project_e17705b6.project_id = projects_by_collection_v1_8247793e.project_id
LEFT JOIN oso.collections_v1 AS collection_2083abff
  ON projects_by_collection_v1_8247793e.collection_id = collection_2083abff.collection_id
LEFT JOIN oso.artifacts_v1 AS artifact_95a01095
  ON github_event_420c9a8e.from_artifact_id = artifact_95a01095.artifact_id
GROUP BY
  1,
  2,
  3
```

## Filtering

Filtering is a key part of any query. The semantic layer provides a way to
filter on the attributes of the models. For instance, if we wanted to filter the
previous query to only include artifacts that are part of a specific namespace,
we could do this:

```python
query = oso.semantic.select(
    "github_event.time",
    "github_event.to->collection.name",
    "github_event.to->artifact.name",
).where(
    "github_event.to->artifact.namespace = 'oso'",
)
```

This would produce the following SQL:

```sql
SELECT
  collection_2083abff.collection_name AS github_event_to__collection_name,
  artifact_95a01095.artifact_name AS github_event_from__artifact_name,
  github_event_420c9a8e.time AS github_event_time
FROM oso.int_events__github AS github_event_420c9a8e
LEFT JOIN oso.artifacts_v1 AS artifact_1b71f23f
  ON github_event_420c9a8e.to_artifact_id = artifact_1b71f23f.artifact_id
LEFT JOIN oso.artifacts_by_project_v1 AS artifacts_by_project_v1_5ee26df1
  ON artifact_1b71f23f.artifact_id = artifacts_by_project_v1_5ee26df1.artifact_id
LEFT JOIN oso.projects_v1 AS project_e17705b6
  ON artifacts_by_project_v1_5ee26df1.project_id = project_e17705b6.project_id
LEFT JOIN oso.projects_by_collection_v1 AS projects_by_collection_v1_8247793e
  ON project_e17705b6.project_id = projects_by_collection_v1_8247793e.project_id
LEFT JOIN oso.collections_v1 AS collection_2083abff
  ON projects_by_collection_v1_8247793e.collection_id = collection_2083abff.collection_id
LEFT JOIN oso.artifacts_v1 AS artifact_95a01095
  ON github_event_420c9a8e.from_artifact_id = artifact_95a01095.artifact_id
WHERE
  artifact_1b71f23f.artifact_namespace = 'oso'
GROUP BY
  1,
  2,
  3
``` 

Additionall, you can also filter on a model's measures. Let's get all the artifacts with 1000 or less events:

```python
query = oso.semantic.select(
    "github_event.time",
    "github_event.to->collection.name",
    "github_event.to->artifact.name",
).where(
    "github_event.count <= 1000",
)
```

This would produce the following SQL:

```sql
SELECT
  collection_2083abff.collection_name AS github_event_to__collection_name,
  artifact_95a01095.artifact_name AS github_event_from__artifact_name,
  github_event_420c9a8e.time AS github_event_time
FROM oso.int_events__github AS github_event_420c9a8e
LEFT JOIN oso.artifacts_v1 AS artifact_1b71f23f
  ON github_event_420c9a8e.to_artifact_id = artifact_1b71f23f.artifact_id
LEFT JOIN oso.artifacts_by_project_v1 AS artifacts_by_project_v1_5ee26df1
  ON artifact_1b71f23f.artifact_id = artifacts_by_project_v1_5ee26df1.artifact_id
LEFT JOIN oso.projects_v1 AS project_e17705b6
  ON artifacts_by_project_v1_5ee26df1.project_id = project_e17705b6.project_id
LEFT JOIN oso.projects_by_collection_v1 AS projects_by_collection_v1_8247793e
  ON project_e17705b6.project_id = projects_by_collection_v1_8247793e.project_id
LEFT JOIN oso.collections_v1 AS collection_2083abff
  ON projects_by_collection_v1_8247793e.collection_id = collection_2083abff.collection_id
LEFT JOIN oso.artifacts_v1 AS artifact_95a01095
  ON github_event_420c9a8e.from_artifact_id = artifact_95a01095.artifact_id
GROUP BY
  1,
  2,
  3
HAVING
  COUNT(github_event_420c9a8e.event_id) <= 1000
```

## Chaining and reusing queries

The semantic layer also provides a way to chain multiple queries together. In
the same way that one may define CTEs in SQL, a named query allows us to
reference a query as if it were just another model in the semantic layer. This
can only happen within a single query builder context, so you must use the same
`oso.semantic` instance to chain queries together that you wish to reuse. In
order to support this, you must name a query using in the `select` method using
the `as_` parameter. Then in subsequent queries you can reference that query 
as if it were just another model in the semantic layer.

Let's find all the projects that published at least one new release in the last
6 months and also had a user operation in ERC-4337.

```python

query = oso.semantic.select(
  "timeseries_metrics_by_project.sum as metric_sum",
  "timeseries_metrics_by_project.project as metric_project",
  as_="github_release_metrics",
).where(
  "metric.name LIKE 'GITHUB_releases_monthly'"
).select(
  "project",
  as_="received_grants",
).where(
  "github_release_metrics.metric.sum > 0"
).select(
  "4337_events.to->project", # need to resolve an ambiguous join with events
  as_="paymaster_projects",
).where(
  "4337_events.event_type LIKE 'CONTRACT_INVOCATION_VIA_PAYMASTER'"
).select(
  "project.name",
  "received_grants.project",
  "paymaster_projects.project",
)
```

This query will produce the following SQL:

```sql
-- The naming here is likely not correct, this needs to be fixed once we implement this
with github_release_metrics as (
  SELECT
    timeseries_metrics_by_project_v1_4f760b72.sum AS metric_sum,
    timeseries_metrics_by_project_v1_4f760b72.project_id AS metric_project
  FROM oso.timeseries_metrics_by_project_v1 AS timeseries_metrics_by_project_v1_4f760b72
  LEFT JOIN oso.timeseries_metrics_v1 AS timeseries_metrics_v1_5ee26df1
    ON timeseries_metrics_by_project_v1_4f760b72.metric_id = timeseries_metrics_v1_5ee26df1.metric_id
  WHERE
    timeseries_metrics_v1_5ee26df1.name LIKE 'GITHUB_releases_monthly'
  GROUP BY
    1,
    2
),
received_grants as (
  SELECT
    project_46f86faa.project_id AS project
  FROM github_release_metrics
  LEFT JOIN oso.projects_v1 AS project_46f86faa
    ON github_release_metrics.metric_project = project_46f86faa.project_id
  WHERE
    github_release_metrics.metric_sum > 0
  GROUP BY
    1

In order to chain queries, a query must be named. When this is done, the query
builder context automatically registers that query as another model in an
temporary registry. This allows us to reference a query as if it were just
another model in the semantic layer. 

### Querying a relationship attribute

While not _always_ useful, it is possible to simply query a relationship
attribute. While not always useful on it's own, this can be important to use
when reusing queries as the semantic layer will automatically.

```python
query = registry.select(
    "project.by_collection",
)
print(query.sql(pretty=True))
```

The output of this query will look like this:

```sql
SELECT
    artifact.artifact_id as artifact__by_project
FROM iceberg.oso.artifacts_v1 as artifact
```

The importance of this query is that assuming that not all projects have
artifacts, this query will return all projects that actually have artifacts.

When using reusing a query this ensures that the `Relationship` is maintained
and can be used by downstream queries.

Like this:

```python
query = registry.select(
    "artifact.source as artifact_source",
    "artifact.by_project"
    as_="source_more_than_100_artifacts"
).where(
    "artifact.count > 100"
).select(
    "source_more_than_100_artifacts.artifact_source",
    "project.name",
)
```

This contrived example will produce a result that returns all projects related
to artifact source that have more than 100 artifacts.

## Full Reference

Much like the OSO data model itself, the object model of the semantic layer is a
dynamic and frequently changing set of abstractions. As such, the reference
documentation of the semantic model is versioned and available [here](?). As the semantic model updates, so too does this living document.

