---
description: Help locate an unknown *entity* (chain, project, collection, etc.) in Pyoso's warehouse
globs: 
alwaysApply: false
---
# Cursor Entity Resolution Protocol

---

## 0. Task decomposition & scope confirmation  *(always first)*

1. **Parse the request.**
   Extract all distinct entity strings.
   â†’ Example:
   *â€œFind Curve, Uniswap, and Baseâ€ â†’ `["Curve", "Uniswap", "Base"]`*

2. **Propose an execution plan.**
   List entities in the order you plan to resolve them (default = listed order).

   > â€œI'll tackle these one at a time:
   >
   > 1. Curve
   > 2. Uniswap
   > 3. Base
   >
   > I'll fully resolve each before moving to the next. Does that plan work?â€

3. **Pause for approval.**
   â†’ Do not proceed without an explicit "Yes" or revised plan from the user.

---

## 1. Supported entity types & search tools

| Entity type    | What it represents                                                       | Search tool         |
| -------------- | ------------------------------------------------------------------------ | ------------------- |
| **Artifact**   | A concrete address / URL / identifier (e.g., contract address, Git repo) | `search_artifact`   |
| **Metric**     | Quantitative measure we track for an artifact/project/collection         | `search_metric`     |
| **Project**    | A discrete product / protocol; owns artifacts                            | `search_project`    |
| **Collection** | Group of related projects                                                | `search_collection` |
| **Model**      | A SQLMesh model (= materialized table)                                   | `search_model`      |
| **Chain**      | Blockchain network (Ethereum, Optimism, etc.)                            | `search_chain`      |

---

## 2. High-level per-entity workflow

For **each entity** in the user-approved list:

1. **Form a ranked hypothesis list**
   Example: `[Project, Artifact, Collection, Metric, Model, Chain]`
   Based on entity name, user context, and past usage.

2. **Pause for confirmation.**

   > â€œFor 'Curve', I think it's most likely a Project, then maybe an Artifact or Collection.
   > Does this order look good: \[Project, Artifact, Collection, â€¦]?â€

3. **Call each `search_*` tool in order** (unless user says otherwise):

   For each type in the hypothesis list:

   * **Call the corresponding search tool**

     * `search_project("Curve")`
     * `search_artifact("Curve")`
     * ...

   * **Evaluate the result**:

     * If no result:

       > â€œNothing found for 'Curve' as a Project.â€
     * If result(s) returned:

       * Run a lightweight plausibility check (e.g. name match, known aliases, chain consistency).
       * If reasonable:

         > â€œFound a plausible match for 'Curve' as a Project. I'll keep that result.â€
       * If questionable:

         > â€œFound something, but I'm not sure it fits â€” want to review or skip it?â€

4. **Return a list of all matched types.**
   Once all types are searched:

   > â€œHere's what I found for 'Curve':
   >
   > * As a Project: Curve Finance
   > * As an Artifact: Contract `0xabcâ€¦` on Ethereum
   > * As a Metric: TVL on Curve pools
   >
   > Does this look good? Would you like to remove or revise any of these?â€

5. **User may approve, reject, or edit matches.**

   * If user confirms â†’ store entity mapping
   * If not â†’ revise and repeat search as needed

---

## 3. Interaction guarantees (per entity)

* Always confirm the hypothesis order before searching.
* Unless told otherwise, **search all types** and **return all relevant matches**.
* Show matches clearly and pause for user approval.
* Fully resolve one entity before moving to the next.
* If user modifies any input mid-way, re-run updated step(s).

---

## 4. Error handling

* If any `search_*` tool fails (timeout, bad input):
  â†’ Briefly show the error, retry once, then ask the user whether to proceed, retry, or skip.

* If a tool returns ambiguous results or many false positives:
  â†’ Notify the user, summarize the issue, and ask whether to continue with lower-confidence results.

* Do not cache or expose sensitive values.

---

## 5. Example multi-entity flow (condensed)

```
USER: "Can you look up 'Curve', 'Uniswap', and 'Base'?"

AGENT:
Got it â€” 3 entities:
1. Curve
2. Uniswap
3. Base

I'll handle them one at a time in that order. Does that work?

USER: Yes.

â€”

ğŸ” CURVE

AGENT:
For "Curve", I think the best order is: [Project, Artifact, Collection, Metric]. OK?

USER: Yes.

â†’ search_project("Curve") â€¦ returns "Curve Finance"
â†’ search_artifact("Curve") â€¦ returns 0xabc...
â†’ search_collection("Curve") â€¦ no results
â†’ search_metric("Curve") â€¦ returns metrics related to Curve's TVL and swap volume

AGENT:
Here's what I found for â€œCurveâ€:
- Project: Curve Finance
- Artifact: Contract 0xabcâ€¦ on Ethereum
- Metric: Daily swap volume

Should I retain all of these?

USER: Keep Project and Metric, drop Artifact.

â†’ Moves to next entity (Uniswap)...
```
